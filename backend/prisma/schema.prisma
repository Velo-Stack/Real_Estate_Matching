generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

// Enums
enum Role {
  ADMIN
  MANAGER
  BROKER
  EMPLOYEE
  DATA_ENTRY_ONLY
}

enum PropertyType {
  LAND
  PROJECT
  PLAN
}

enum UsageType {
  RESIDENTIAL
  COMMERCIAL
  ADMINISTRATIVE
  INDUSTRIAL
  AGRICULTURAL
}

enum LandStatus {
  RAW
  DEVELOPED
}

enum ExclusivityType {
  EXCLUSIVE
  NON_EXCLUSIVE
}

enum PurposeType {
  SALE
  RENT
  PARTNERSHIP
  INVESTMENT
}

enum SubmittedByType {
  OWNER
  AGENT
  DIRECT_BROKER
  BROKER
  BUYER
}

enum PropertySubType {
  LAND
  APARTMENT
  VILLA
  FLOOR
  TOWNHOUSE
  DUPLEX
  PALACE
  RESIDENTIAL_BUILDING
  COMMERCIAL_BUILDING
  RESIDENTIAL_TOWER
  HOTEL
  HOSPITAL
  SHOWROOM
  RESIDENTIAL_COMPOUND
  OFFICE
  OFFICE_TOWER
  ADMIN_BUILDING
  EXISTING_WAREHOUSE
  LOW_RISK_WORKSHOP
  HIGH_RISK_WORKSHOP
  FACTORY
  EXISTING_FARM
  RESORT
  CHALET
}

enum ContractType {
  WITH_MEDIATION_CONTRACT
  WITHOUT_MEDIATION_CONTRACT
}

enum PriorityType {
  HIGH
  MEDIUM
  LOW
}

enum MatchStatus {
  NEW
  CONTACTED
  NEGOTIATION
  CLOSED
  REJECTED
}

enum NotificationStatus {
  UNREAD
  READ
  ARCHIVED
}

enum NotificationType {
  MATCH
  MESSAGE
  SYSTEM
}

enum AuditAction {
  CREATE
  UPDATE
  DELETE
}

enum UserStatus {
  ACTIVE
  SUSPENDED
  BANNED
  DELETED
}

// Models
model User {
  id       Int    @id @default(autoincrement())
  email    String @unique
  name     String
  phone    String?
  password String
  role     Role   @default(BROKER)
  status   UserStatus @default(ACTIVE)

  createdOffers            Offer[]
  createdRequests          Request[]
  notifications            Notification[]
  auditLogs                AuditLog[]
  teamMemberships          TeamMember[]
  conversationParticipants ConversationParticipant[]
  messagesSent             Message[]
  submissionLinks          UserSubmissionLink[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model UserSubmissionLink {
  id             Int      @id @default(autoincrement())
  userId         Int
  user           User     @relation(fields: [userId], references: [id])
  tokenHash      String   @unique
  allowedActions Json?
  expiresAt      DateTime?
  isActive       Boolean  @default(true)
  createdById    Int?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
}

model Offer {
  id Int @id @default(autoincrement())

  // Mandatory/Optional Fields
  type           PropertyType
  usage          UsageType
  landStatus     LandStatus? // made optional per request
  city           String?
  district       String?
  cityId         Int?
  neighborhoodId Int?
  purpose        PurposeType?
  brokersCount   Int?
  submittedBy    SubmittedByType?
  propertySubType PropertySubType?
  boundaries     String?
  lengths        String?
  facades        String?
  brokerContactName  String?
  brokerContactPhone String?

  areaFrom     Float
  areaTo       Float
  priceFrom    Decimal         @db.Decimal(15, 2)
  priceTo      Decimal         @db.Decimal(15, 2)
  exclusivity  ExclusivityType
  contractType ContractType? // new field for 'طبيعة التعاقد'

  // Optional Fields
  coordinates String?
  description String?

  // Relations
  createdById Int
  createdBy   User @relation(fields: [createdById], references: [id])

  // Team relation
  teamId Int?
  team   Team? @relation("TeamOffers", fields: [teamId], references: [id])

  cityRel         City?         @relation(fields: [cityId], references: [id])
  neighborhoodRel Neighborhood? @relation(fields: [neighborhoodId], references: [id])
  matches         Match[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Request {
  id Int @id @default(autoincrement())

  // Mandatory/Optional Fields
  type           PropertyType
  usage          UsageType
  purpose        PurposeType? // added to support matching by purpose
  landStatus     LandStatus? // made optional
  city           String?
  district       String?
  cityId         Int?
  neighborhoodId Int?
  submittedBy    SubmittedByType?
  propertySubType PropertySubType?
  description    String?
  brokerContactName  String?
  brokerContactPhone String?

  areaFrom   Float
  areaTo     Float
  budgetFrom Decimal      @db.Decimal(15, 2)
  budgetTo   Decimal      @db.Decimal(15, 2)
  priority   PriorityType

  // Relations
  createdById Int
  createdBy   User @relation(fields: [createdById], references: [id])

  // Team relation
  teamId Int?
  team   Team? @relation("TeamRequests", fields: [teamId], references: [id])

  cityRel         City?         @relation(fields: [cityId], references: [id])
  neighborhoodRel Neighborhood? @relation(fields: [neighborhoodId], references: [id])
  matches         Match[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Match {
  id Int @id @default(autoincrement())

  offerId   Int
  requestId Int

  offer   Offer   @relation(fields: [offerId], references: [id])
  request Request @relation(fields: [requestId], references: [id])

  score  Float // 0-100
  status MatchStatus @default(NEW)

  notifications Notification[] // A match can generate notifications

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([offerId, requestId])
}

model City {
  id            Int            @id @default(autoincrement())
  name          String
  neighborhoods Neighborhood[]
  offers        Offer[]
  requests      Request[]
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
}

model Neighborhood {
  id        Int       @id @default(autoincrement())
  name      String
  cityId    Int
  city      City      @relation(fields: [cityId], references: [id])
  offers    Offer[]
  requests  Request[]
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
}

enum TeamType {
  LANDS
  PROPERTIES
  MAINTENANCE
  RENTAL
  ASSET_MANAGEMENT
}

enum TeamRole {
  MANAGER
  MEMBER
}

model Team {
  id            Int            @id @default(autoincrement())
  name          String         @unique
  type          TeamType
  members       TeamMember[]
  conversations Conversation[]
  offers        Offer[]        @relation("TeamOffers")
  requests      Request[]      @relation("TeamRequests")
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @default(now()) @updatedAt
}

model TeamMember {
  id        Int      @id @default(autoincrement())
  teamId    Int
  team      Team     @relation(fields: [teamId], references: [id])
  userId    Int
  user      User     @relation(fields: [userId], references: [id])
  role      TeamRole @default(MEMBER)
  createdAt DateTime @default(now())
}

model Conversation {
  id            Int                       @id @default(autoincrement())
  title         String?
  teamId        Int?
  team          Team?                     @relation(fields: [teamId], references: [id])
  participants  ConversationParticipant[]
  messages      Message[]
  notifications Notification[]
  createdAt     DateTime                  @default(now())
  updatedAt     DateTime                  @default(now()) @updatedAt
}

model ConversationParticipant {
  id             Int          @id @default(autoincrement())
  conversationId Int
  conversation   Conversation @relation(fields: [conversationId], references: [id])
  userId         Int
  user           User         @relation(fields: [userId], references: [id])
  createdAt      DateTime     @default(now())
}

model Message {
  id             Int          @id @default(autoincrement())
  conversationId Int
  conversation   Conversation @relation(fields: [conversationId], references: [id])
  senderId       Int
  sender         User         @relation(fields: [senderId], references: [id])
  body           String
  readBy         Json? // array of userIds who read the message
  createdAt      DateTime     @default(now())
}

model Notification {
  id Int @id @default(autoincrement())

  userId Int
  user   User @relation(fields: [userId], references: [id])

  type NotificationType @default(MATCH)

  matchId Int?
  match   Match? @relation(fields: [matchId], references: [id])

  conversationId Int?
  conversation   Conversation? @relation(fields: [conversationId], references: [id])

  meta Json? // arbitrary metadata, e.g., message snippet

  status NotificationStatus @default(UNREAD)

  createdAt DateTime @default(now())
}

model AuditLog {
  id Int @id @default(autoincrement())

  userId Int
  user   User @relation(fields: [userId], references: [id])

  action     AuditAction
  resource   String // "Offer", "Request", "User", etc.
  resourceId Int? // ID of the affected resource

  oldValues Json? // Previous state (for UPDATE/DELETE)
  newValues Json? // New state (for CREATE/UPDATE)

  ipAddress String?
  userAgent String?

  createdAt DateTime @default(now())
}
